1.变量 进阶（理解）

1.1 变量的引用
。变量和数据都是保存在内存中的
。在python中函数的参数传递以及返回值都是靠引用传递的。

引用的概念：
在 Python中
·变量和数据是分开存储的
数据保存在内存中的一个位置
·变量中保存着数据在内存中的地址
变量中记录数据的地址,就叫做引用
·使用id()函数可以查看变量中保存数据所在的内存地址
注意:如果变量已经被定义,当给一个变量赋值的时候,本质上是修改了数据的引用
变量不再对之前的数据引用
·变量改为对新赋值的数据引用

a = 1   #看到赋值语句，首先把注意力放在等号的右侧


1.2 函数的参数和返回值的传递
在python中，函数的实参/返回值都是靠引用来传递来的

数据的地址本质上就是一个数字

调用函数时，本质上传递的是实参保存数据的引用，而不是实参保存的数据

注意：如果函数有返回值，但是没有定义变量接收，程序不会报错，但是无法获得返回结果
比如：r = test(a)

函数返回的值，返回的是数据的引用，而不是数据本身。

1.3 可变和不可变类型
。不可变类型，内存中的数据不允许被修改。

数字类型 int,bool, float, complex,long(2.x)
字符串 str
元 组 tuple

。可变类型,内存中的数据可以被修改:

列表ist
字典dict

注意:字典的key只能使用不可变类型的数据
注意
1.可变类型的数据变化,是通过方法来实现的
2.如果给一个可变类型的变量,赋值了一个新的数据,引用会修改
·变量不再对之前的数据引用
变量改为对新赋值的数据引用


要增加字典的值，可以使用 d['age'] = 18 的方法来新增
没有的键和值。

 哈希(hash)
 Python中内置有一个名字叫做hash(o)的函数
。接收一个不可变类型的数据作为参数
。返回结果是一个整数

·哈希是一种算法,其作用就是提取数据的特征码(指纹)
。相同的内容得到相同的结果
。不同的内容得到不同的结果
·在 Python中,设置字典的键值对时,会首先对key进行 hash 已决定如何在内存中保存字典的数
据,以方便后续对字典的操作:增、删、改、查
。键值对的key必须是不可变类型数据
。键值对的vale可以是任意类型的数据


2.局部变量和全局变量
·局部变量是在函数内部定义的变量,只能在函数内部使用
全局变量是在函数外部定义的变量(没有定义在某一个函数内),所有函数内部都可以使用这个变量
提示:在其他的开发语言中,大多不推荐使用全局变量--可变范围太大,导致程序不
好维护!

2.1局部变量
·局部变量是在函数内部定义的变量,只能在函数内部使用
函数执行结束后,函数内部的局部变量,会被系统回收
·不同的函数,可以定义相同的名字的局部变量,但是各用个的不会产生影响
局部变量的作用
·在函数内部使用,临时保存函数内部需要使用的数据

局部变量的生命周期
所谓生命周期就是变量从被创建到被系统回收的过程
局部变量在函数执行时才会被创建
函数执行结束后局部变量被系统回收
局部变量在生命周期内,可以用来存储函数内部临时使用到的数据


2.2 全局变量
全局变量是在函数外部定义的变量,所有函数内部都可以使用这个变量
#定义一个全局变量
 num =10
 def demol():
 print(num)
 def demo2():
 print(num)
 demo1()
 demo2()
 print("over")

***一个独立的python文件，就是模块***

注意:函数执行时,需要处理变量时会:
1.首先查找函数内部是否存在指定名称的局部变量,如果有,直接使用
2.如果没有,查找函数外部是否存在指定名称的全局变量,如果有,直接使用
3.如果还没有,程序报错!
1)函数不能直接修改全局变量的引用
全局变量是在函数外部定义的变量(没有定义在某一个函数内),所有函数内部都可以使用这个变量
提示:在其他的开发语言中,大多不推荐使用全局变量可变范围太大,导致程序不
好维护!
·在函数内部,可以通过全局变量的引用获取对应的数据
·但是,不允许直接修改全局变量的引用使用赋值语句修改全局变量的值


2)在函数内部修改全局变量的值
·如果在函数中需要修改全局变量,需要使用 global进行声明
 num =10
 def demol():
 print("demo1"+"_"* 50)
# global关键字,告诉 Python解释器num是一个全局变量
 global num
#只是定义了一个局部变量,不会修改到全局变量,只是变量名相同而已
 num =100
 print(num)
 def demo2():
 print("demo2"+"-"*50)
 print(num)
 demo1()
 demo2()
 print("over")


全局变量定义的位置：
为了保证所有的函数都能够正确使用到全局变量，因该将全局变量定义在其他
函数的上方。

4)全局变量命名的建议
为了避免局部变量和全局变量出现混淆,在定义全局变量时,有些公司会有一些开发要求,例如:
·全局变量名前应该增加g或者gL的前缀
提示:具体的要求格式,各公司要求可能会有些差异


***在pycharm里修改全局变量可以先选中变量名，鼠标右键选择全部修改，或者是shift + F6 ***


3.函数参数和返回值的作用
函数根据有没有参数以及有没有返回值,可以相互组合,一共有4种组合形式
1.无参数,无返回值
2.无参数,有返回值
3.有参数,无返回值
4.有参数,有返回值

定义函数时,是否接收参数,或者是否返回结果,是根据实际的功能需求来决定的!
1.如果函数内部处理的数据不确定,就可以将外界的数据以参数传递到函数内部
2.如果希望一个函数执行完成后,向外界汇报执行结果,就可以增加函数的返回值

·在程序开发中,有时候,会希望一个函数执行结束后,告诉调用者一个结果,以便调用者针对具体的结
果做后续的处理
·返回值是函数完成工作后,最后给调用者的一个结果
·在函数中使用return关键字可以返回结果
·调用函数一方,可以使用变量来接收函数的返回结果
问题:一个函数执行后能否返回多个结果?

#元祖-可以包含多个数据，因此可以使用元祖让函数一次返回多个值
return (temp,wetness)
# 如果函数返回的类型是元祖，小括号可以省略

#如果函数返回的类型是元组，同时希望单独的处理元组中的元素
#可以使用多个变量，一次接收函数的返回结果
#注意：使用多个变量接收结果时，变量的个数因该和元祖中元素的个数保持一致
例子: gl_temp, gl_wetness = measure()

4.不可变和可变的参数
无论传递的参数是可变还是不可变，只要针对参数使用 “赋值” 语句，会在函数内部修改
局部变量的引用，不会影响到外部变量的引用。

如果传递的参数是可变类型，在函数内部，使用 “方法” 修改了数据的内容，同样会影响到
外部的数据。


***#列表变量使用 += 不会做相加再赋值的操作！本质是在调用列表的extend方法。***


4.函数的缺省参数
·定义函数时,可以给某个参数指定一个默认值,具有默认值的参数就叫做缺省参数
调用函数时,如果没有传入缺省参数的值,则在函数内部使用定义函数时指定的参数默认值
·函数的缺省参数,将常见的值设置为参数的缺省值,从而简化函数的调用
例如:对列表排序的方法
 gl num_list=[6,3,9]
#默认就是升序排序,因为这种应用需求更多
 gl num_list.sort()
 print(gl num_list)
#只有当需要降序排序时,才需要传递 reverse参数
 gl_num_list. sort(reverse=True)
 print(gl_num_list)

#如果需要降序排序，需要执行reverse参数
如：gl_list.sort(reverse=True)

提示：
1.缺省参数，需要使用 最常见的值作为默认值！
2.如果一个参数的值不能确定，则不因该设置默认值，具体的数值在调用函数时，由外界传递。
如：班上男生居多，就可以这样设置
def print_info(name,gender=True)   #这个True就是gender的默认参数，也就是缺省参数，gender 为True则为男生，False则为女生

print_info("小美", False)     #返回的值便为女生

缺省参数的注意事项
1)缺省参数的定义位置
·必须保证带有默认值的缺省参数在参数列表末尾
所以,以下定义是错误的!
 def print_info(name, gender=True, title):
2)调用带有多个缺省参数的函数
在调用函数时,如果有多个缺省参数,需要指定参数名,这样解释器才能够知道参数的对应关系!
(比如，gender=Flase要像这样指定)

5.多值参数
定义支持多值参数的函数
·有时可能需要一个函数能够处理的参数个数是不确定的,这个时候,就可以使用多值参数
 python中有两种多值参数:
。参数名前增加一个*可以接收元组
。参数名前增加两个*可以接收字典
一般在给多值参数命名时,习惯使用以下两个名字
*args--存放元组参数,前面有一个*
**kwargs--存放字典参数,前面有两个*
args是 arguments的缩写,有变量的含义
kw是 keyword的缩写, kwargs可以记忆键值对参数
 def demo(num, *args, *kwargs):
     print(num)
     print(args)
     print(kwargs)

 demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True)

提示:多值参数的应用会经常出现在网络上一些大牛开发的框架中,知道多值参数,有
利于我们能够读懂大牛的代码

eg:
def sum numbers(*args):
    num = 0
    print(args)
    #循环遍历
     for n in args:
           num += n
      return num
 result = sum_numbers(1, 2, 3, 4,5)
 print(result)


6.元组和字典的拆包(知道)
·在调用带有多值参数的函数时,如果希望:
将一个元组变量,直接传递给args
将一个字典变量,直接传递给 kwargs
·就可以使用拆包,简化参数的传递,拆包的方式是:
。在元组变量前,增加一个*
。在字典变量前,增加两个*
 def demo(*args, **kwargs):
 print(args)
 print(kwargs)
#需要将一个元组变量/字典变量传递给函数对应的参数
 gl_nums =(1, 2, 3)
 glxiaoming={"name":"小明,"age":18}
#会把 num tuple和 xiaoming作为元组传递个args
 demo(gl_nums, gl_xiaoming)
 demo(*_nums, **gl_xiaoming)


7.函数的递归
函数调用自身的编程技巧称为递归

递归函数的特点：
特点
一个函数内部调用自己
。函数内部可以调用其他函数,当然在函数内部也可以调用自己

代码特点
1.函数内部的代码是相同的,只是针对参数不同,处理的结果不同
2.当参数满足一个条件时,函数不再执行
·这个非常重要,通常被称为递归的出口,否则会出现死循环!
示例代码
 def sum numbers(num):
     print(num)
     #递归的出口很重要,否则会出现死循环
      if num == 1:
 	return
      sum_numbers(num-1)
 
sum_numbers(3)

eg:
def sum_numbers(num):
    #1.出口
    if num == 1:
           return 1
    #数字的累加 num + (1....num -1)
    #假设 sum_numbers 能够正确的处理 1....num -1
    temp  = sum_numbers(num -1)

    #两个数字的相加
    return num + temp

result = sum_numbers(100)
print(result)

验证：
def sum_numbers(num):

    if num == 98:
        return 1

    temp  = sum_numbers(num -1)

    return num + temp 

    
result = sum_numbers(100)
print(result)

>>>200  #最后返回的值是两百，所以相当于temp有等于99，最后在98的时候返回了1，所以最后等于了200.


提示：递归是一个编程技巧，初次接触递归会感觉有些吃力！在处理不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构












