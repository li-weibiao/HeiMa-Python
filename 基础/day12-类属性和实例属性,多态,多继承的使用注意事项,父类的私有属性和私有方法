1. 父类的私有属性和私有方法
1.子类对象不能在自己的方法内部,直接访问父类的私有属性或私有方法
2.子类对象可以通过父类的公有方法 间接访问到私有属性或私有方法
·私属性、方法是对象的隐私,不对外公开,外界以及子类都不能直接访问
·私有属性、方法通常用于做一些内部的事情

#在外界不能直接访问对象的私有属性/调用私有方法

2.多继承
概念
。子类可以拥有多个父类，并且具有所有父亲的属性和方法
。例如：孩子会继承自己父亲和母亲的特性

语法：
class  子类名(父类名1，父类名2...)
    pass

#多继承可以让子类对象，同时具有多个父类的属性和方法

2.1多继承的使用注意事项
问题的提出
·如果不同的父类中存在同名的方法,子类对象在调用方法时,会调用哪一个父类中的方法呢?
提示:开发时,应该尽量避免这种容易产生混淆的情况!如果父类之间存在同名
的属性或者方法,应该尽量避免使用多继承


 Python中的MR--方法搜索顺序(知道)
 Python中针对类提供了一个内置属性 __mro__可以查看方法搜索顺序
MRO是 ethod resolution order,主要用于在多继承时判断方法、属性的调用路径
 print(C. __mro__)
输出结果
 (<class '_main_. C'>, <class 'main. A'>, <class 'main_.B'>, <class 'object'>)
·在搜索方法时,是按照__mro__的输出结果从左至右的顺序查找的
·如果在当前类中找到方法,就直接执行,不再搜索
·如果没有找到,就查找下一个类中是否有对应的方法,如果找到,就直接执行,不再搜索
·如果找到最后一个类,还没有找到方法,程序报错


2.2新式类与旧式(经典)类
 object是 Python为所有对象提供的基类,提供有一些内置的属性和方法,可以使用
dir函数查看

·新式类:以 object为基类的类,推荐使用
●经典类:不以 object为基类的类,不推荐使用

·在 Python3中定义类时,如果没有指定父类,会默认使用 object作为该类的基类-
 Python3.x 中定义的类都是新式类
·在 Python2.x中定义类时,如果没有指定父类,则不会以 object作为基类

新式类和经典类在多继承时-会影响到方法的搜索顺序

为了保证编写的代码能够同时在 Python2.x和 Python3.运行
今后在定义类时,如果没有父类,建议统一继承自 object
 class  类名(object):
     pass


3.多态
面向对象三大特性
1.封装根据职责将属性和方法封装到一个抽象的类中
·定义类的准则
2.继承实现代码的重用,相同的代码不需要重复的编写
·设计类的技巧
子类针对自己特有的需求,编写特定的代码
3.多态 不同的子类对象调用相同的父类方法,产生不同的执行结果
。多态可以增加代码的灵活度
。以继承和重写父类方法为前提
。是调用方法的技巧,不会影响到类的内部设计

#在定义类的时候，如果没有指定的父类，则可以指定object为父类。

eg:和狗玩耍
class Dog(object):

    def __init__(self,name):
        self.name = name
        
    def game(self):
        print("%s 蹦蹦跳跳的玩耍..." % self.name)


class XiaoTianDog(Dog):

    def game(self):
        print("%s 飞到天上去玩耍..." % self.name)     #重新修改了父类的方法


class Person(object):

    def __init__(self,name):
        self.name = name

    def game_with_dog(self,dog):
        print("%s 和 %s 快乐的玩耍..." % (self.name,dog.name))

        #让狗玩耍
        dog.game()

#1.创建一个狗对象
#wangcai = Dog("旺财")
wangcai = XiaoTianDog("飞天旺财")
#2.创建一个小明对象
xiaoming = Person("小明")

#3.让小明调用和狗玩的方法
xiaoming.game_with_dog(wangcai)
        
 案例小结:
 Person类中只需要让狗对象调用game方法,而不关心具体是什么狗
game方法是在Dog父类中定义的
·在程序执行时,传入不同的狗对象实参,就会产生不同的执行效果


4.类的结构

1.1术语实例
1.使用面相对象开发,第1步是设计类
2.使用 类名0 创建对象,创建对象的动作有两步:
1)在内存中为对象分配空间
2)调用初始化方法__init__为对象初始化
3.对象创建后,内存中就有了一个对象的实实在在的存在一实例

因此,通常也会把
1.创建出来的对象叫做类的实例
2.创建对象的动作叫做实例化
3.对象的属性叫做实例属性
4.对象调用的方法叫做实例方法

在程序执行时:
1.对象各自拥有自己的实例属性
2.调用对象方法,可以通过 self.
·访问自己的属性
·调用自己的方法
结论
·每一个对象都有自己独立的内存空间保存各自不同的属性
·多个对象的方法,在内存中只有一份,在调用方法时,需要把对象的引用传递到方法内部


1.2类是一个特殊的对象
 Python中一切皆对象:
class  AAA:       定义的类属于类对象
obj1 = AAA()   属于实例对象

在程序运行时,类同样会被加载到内存
·在 Python中,类是一个特殊的对象--类对象
·在程序运行时,类对象在内存中只有一份,使用一个类可以创建出很多个对象实例
除了封装实例的属性和方法外,类对象还可以拥有自己的属性和方法
1.类属性
2.类方法
·通过类名.的方式可以访问类的属性或者调用类的方法

02.类属性和实例属性
2.1概念和使用
类属性就是给类对象中定义的属性
·通常用来记录与这个类相关的特征
·类属性不会用于记录具体对象的特征
示例需求
定义一个工具类
每件工具都有自己的name
需求一知道使用这个类,创建了多少个工具对象?

class Tool(object):
    #使用赋值语句,定义类属性,记录创建工具对象的总数
     count = 0
    def  __init__(self, name):
          self.name = name       
          #针对类属性做一个计数+1
           Tool. count += 1

#创建工具对象
tool1=tool(斧头")
tool2=tool(榔头")
tool3=tool("铁锹")

#输出工具对象的总数
print(Tool.count)


2.2 属性的获取机制
。在python中属性的获取存在一个向上查找机制

因此，要访问类属性有两种方式：
1. 类名.类属性
2.对象.类属性（不推荐）

注意：
。如果使用 对象.类属性 = 值 赋值语句，只会给对象添加一个属性，而不会影响到类属性的值。


5.类方法和静态方法


3.1类方法
类属性就是针对 类对象定义的属性
使用赋值 class语句在关键字下方可以定义类属性
类属性用于记录与这个类相关的特征

·类方法就是针对类对象定义的方法
。在类方法内部可以直接访问类属性或者调用其他的类方法
语法如下
@classmethod
 def类方法名(cls):
     pass
·类方法需要用修饰器classmethod来标识,告诉解释器这是一个类方法
·类方法的第一个参数应该是 cls
。由哪一个类调用的方法,方法内的cls就是哪一个类的引用
。这个参数和实例方法的第一个参数是 self类似
。提示使用其他名称也可以,不过习惯使用cls
·通过类名.调用类方法,调用方法时,不需要传递cls参数
·在方法内部
。可以通过cls.访问类的属性
。也可以通过cls.调用其他的类方法
在类方法内部,可以直接使用cls访问类属性或者调用类方法

eg:类方法
class Tool(object):

    #使用赋值语句定义类属性，记录所有工具对象的数量
    count = 0

    @classmethod
    def show_tool_count(cls):

        print("工具对象的数量 %d" % cls.count)

    def __init__(self,name):
        self.name = name

        #让类属性的值+1
        Tool.count += 1


#创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")


#调用类方法
Tool.show_tool_count()


3.2静态方法
·在开发时,如果需要在类中封装一个方法,这个方法:
。既不需要访问实例属性或者调用实例方法
。也不需要访问类属性或者调用类方法
·这个时候,可以把这个方法封装成一个静态方法

语法如下
@staticmethod
def  静态方法名():
     pass
·静态方法需要用修饰器@staticmethod来标识,告诉解释器这是一个静态方法
通过类名.调用静态方法

eg:静态方法
class Dog(object):

    @staticmethod
    def run():
        #不访问实例属性/类属性
        print("小狗要跑...")


#通过类名.调用静态方法(不需要创建狗对象)
Dog.run()

        

eg:方法综合案例
class Game(object):

    #历史最高分
    top_score = 0
    

    def __init__(self,player_name):
        self.player_name = player_name

    @staticmethod
    def show_help():
        print("帮助信息：让小狗进入大门")

    @classmethod
    def show_top_score(cls):
        print("历史记录 %d" % cls.top_score)

    def start_game(self):     #定义一个实例方法
        print("%s 开始游戏啦..." % self.player_name)


#1.查看游戏的帮助信息（主程序）
Game.show_help()

#2.查看历史最高分
Game.show_top_score() 

#3.创建游戏对象
game = Game("小明")

game.start_game()


        
案例小结
1.实例方法--方法内部需要访问实例属性
。实例方法  内部可以使用类名.访问类属性
2.类方法--方法内部只需要访问类属性
3.静态方法--方法内部,不需要访问实例属性和类属性

提问
如果方法内部即需要访问实例属性,又需要访问类属性,应该定义成什么方法?
答案
应该定义实例方法
·因为,类只有一个,在实例方法内部可以使用类名访问类属性
